// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TextureInterpolate

#define TEXTURE_DIMENSIONS 256.0

 // Convert an xyz vector to a uvw Texture2DArray sample as if it were a cubemap
float3 xyz_to_uvw(float3 xyz)
{
	// Find which dimension we're pointing at the most
	float3 absxyz = abs(xyz);
	int xMoreY = absxyz.x > absxyz.y;
	int yMoreZ = absxyz.y > absxyz.z;
	int zMoreX = absxyz.z > absxyz.x;
	int xMost = (xMoreY) && (!zMoreX);
	int yMost = (!xMoreY) && (yMoreZ);
	int zMost = (zMoreX) && (!yMoreZ);

	// Determine which index belongs to each +- dimension
	// 0: +X; 1: -X; 2: +Y; 3: -Y; 4: +Z; 5: -Z;
	float xSideIdx = 0 + (xyz.x < 0);
	float ySideIdx = 2 + (xyz.y < 0);
	float zSideIdx = 4 + (xyz.z < 0);

	// Composite it all together to get our side
	float side = xMost * xSideIdx + yMost * ySideIdx + zMost * zSideIdx;

	// Depending on side, we use different components for UV and project to square
	float3 useComponents = float3(0, 0, 0);
	if (xMost) useComponents = xyz.yzx;
	if (yMost) useComponents = xyz.xzy;
	if (zMost) useComponents = xyz.xyz;
	float2 uv = useComponents.xy / useComponents.z;

	// Transform uv from [-1,1] to [0,1]
	uv = uv * 0.5 + float2(0.5, 0.5);

	return float3(uv, side);
}

// Convert an xyz vector to the side it would fall on for a cubemap
// Can be used in conjuction with xyz_to_uvw_force_side
float xyz_to_side(float3 xyz)
{
	// Find which dimension we're pointing at the most
	float3 absxyz = abs(xyz);
	int xMoreY = absxyz.x > absxyz.y;
	int yMoreZ = absxyz.y > absxyz.z;
	int zMoreX = absxyz.z > absxyz.x;
	int xMost = (xMoreY) && (!zMoreX);
	int yMost = (!xMoreY) && (yMoreZ);
	int zMost = (zMoreX) && (!yMoreZ);

	// Determine which index belongs to each +- dimension
	// 0: +X; 1: -X; 2: +Y; 3: -Y; 4: +Z; 5: -Z;
	float xSideIdx = 0 + (xyz.x < 0);
	float ySideIdx = 2 + (xyz.y < 0);
	float zSideIdx = 4 + (xyz.z < 0);

	// Composite it all together to get our side
	return xMost * xSideIdx + yMost * ySideIdx + zMost * zSideIdx;
}

// Convert an xyz vector to a uvw Texture2DArray sample as if it were a cubemap
// Will force it to be on a certain side
float3 xyz_to_uvw_force_side(float3 xyz, float side)
{
	// Depending on side, we use different components for UV and project to square
	float3 useComponents = float3(0, 0, 0);
	if (side < 2) useComponents = xyz.yzx;
	if (side >= 2 && side < 4) useComponents = xyz.xzy;
	if (side >= 4) useComponents = xyz.xyz;
	float2 uv = useComponents.xy / useComponents.z;

	// Transform uv from [-1,1] to [0,1]
	uv = uv * 0.5 + float2(0.5, 0.5);

	return float3(uv, side);
}

// Convert a uvw Texture2DArray coordinate to the vector that points to it on a cubemap
float3 uvw_to_xyz(float3 uvw)
{
	// Use side to decompose primary dimension and negativity
	int side = uvw.z;
	int xMost = side < 2;
	int yMost = side >= 2 && side < 4;
	int zMost = side >= 4;
	int wasNegative = side & 1;

	// Insert a constant plane value for the dominant dimension in here
	uvw.z = 1;

	// Depending on the side we swizzle components back (NOTE: uvw.z is 1)
	float3 useComponents = float3(0, 0, 0);
	if (xMost) useComponents = uvw.zxy;
	if (yMost) useComponents = uvw.xzy;
	if (zMost) useComponents = uvw.xyz;

	// Transform components from [0,1] to [-1,1]
	useComponents = useComponents * 2 - float3(1, 1, 1);
	useComponents *= 1 - 2 * wasNegative;

	if (xMost && !wasNegative) useComponents = float3(1.0, 1.0 - uvw.y, 1.0 - uvw.x) * 2 - float3(1, 1, 1);
	if (xMost && wasNegative) useComponents = float3(0.0, 1.0 - uvw.y, uvw.x) * 2 - float3(1, 1, 1);
	if (yMost && wasNegative) useComponents = float3(uvw.x, 0.0, 1.0 - uvw.y) * 2 - float3(1, 1, 1);
	if (zMost && !wasNegative) useComponents = float3(uvw.x, 1.0 - uvw.y, 1.0) * 2 - float3(1, 1, 1);

	return useComponents;
}

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2DArray<float4> Result;

Texture2DArray<float4> Tex[12];

int3 index;

float4 weight;

float3x3 rMatrix;

float4 SampleTexOffset(int index, int3 pos)
{
	float3 sampleVec;
	sampleVec.x = pos.x / TEXTURE_DIMENSIONS;
	sampleVec.y = pos.y / TEXTURE_DIMENSIONS;
	sampleVec.z = pos.z;

	sampleVec = uvw_to_xyz(sampleVec);

	sampleVec = mul(rMatrix, sampleVec);

	sampleVec = xyz_to_uvw(sampleVec);

	return Tex[2][int3(sampleVec.x * TEXTURE_DIMENSIONS, sampleVec.y * TEXTURE_DIMENSIONS, sampleVec.z)];

	//if (xyz_to_uvw(sampleVec).z == 0) {
	//	return float4(0.0, 0.0, 0.0, 1.0);
	//}

	//sampleVec = sampleVec / 2.0 + 0.5;
	//return float4(sampleVec.x, sampleVec.y, sampleVec.z, 1.0);
}

float4 SampleTex(int index, int3 pos)
{
	if (index == 0)
	{
		return Tex[0][pos];
	}
	else if (index == 1)
	{
		return Tex[1][pos];
	}
	else if (index == 2)
	{
		return Tex[2][pos];
	}
	else if (index == 3)
	{
		return Tex[3][pos];
	}
	else if (index == 4)
	{
		return Tex[4][pos];
	}
	else if (index == 5)
	{
		return Tex[5][pos];
	}
	else if (index == 6)
	{
		return Tex[6][pos];
	}
	else if (index == 7)
	{
		return Tex[7][pos];
	}
	else if (index == 8)
	{
		return Tex[8][pos];
	}
	else if (index == 9)
	{
		return Tex[9][pos];
	}
	else if (index == 10)
	{
		return Tex[10][pos];
	}
	else
	{
		return Tex[11][pos];
	}
}

[numthreads(8, 8, 6)]
void TextureInterpolate(uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	float4 Color0 = SampleTex(index.x, int3(id.x, id.y, id.z));
	float4 Color1 = SampleTex(index.y, int3(id.x, id.y, id.z));
	float4 Color2 = SampleTex(index.z, int3(id.x, id.y, id.z));

	float4 Color = SampleTexOffset(index.x, int3(id.x, id.y, id.z));

	Result[int3(id.x, id.y, id.z)] = Color;
		//weight.x * Color0 + weight.y * Color1 + weight.z * Color2;

}
